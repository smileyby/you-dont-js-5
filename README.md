作用域闭包
=========

接下来的内容需要对作用域工作原理相关内容和基础知识有非常深入的了解。

我们将注意力转移带这门语言中一个非常重要但又难以掌握，近乎神话的概念：闭包。如果你了解了之前关于词法作用域的讨论，那么闭包的概念几乎是不言而喻的。魔术师的幕布后藏着一个人，我们将要解开它的伪装。我们没说这个人是Crokford！

在继续学习之前，如果你还是对词法作用域相关内容有疑问，可以回顾下第2章中的相关内容，现在是一个好机会。

## 5.1 启示

对于那些有一点JavaScript使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作是某种意义上的重生，但是需要付出非常多的努力和牺牲才能真正理解这个概念。

回忆我前几年的时光，大量使用JavaScript但却完全不理解闭包是什么。总是感觉这门语言有其隐蔽的一面，如果能够掌握将会功力大增，但讽刺的是我始终无法掌握其中的门道。还记得我曾经大量阅读早期框架的源码，试图能够理解闭包的工作原理。现在还能回忆起我的脑海中第一次浮现出关于“模块模式”相关概念时的激动心情。

那时我无法理解并且请进数年心血来探索，也就是我马上要传授你的秘诀：JavaScript中闭包无处不在，你只需要能够识别并拥抱它。闭包并不是一个需要学习的新的语法和模式才能使用的工具，它也不是一件必须接受Luke一样的原力训练才能使用和掌握的武器。

闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用他们而有意地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你的意愿来识别，拥抱和影响闭包的思维环境。

最后你恍然大悟：原来我的代码中已经到处都是闭包了。现在我终于理解他们了。节必报就好像Neo第一次见到矩阵一样。

## 5.2 实质问题

好了，夸张和浮夸的电影比喻已经够多了。

下面是直接了当的定义，你需要掌握它才能理解和识别闭包：

当函数可以记住并访问所在的此法作用域时，就产生了闭包，计时函数是在当前词法作用域之外执行。

下面用一些代码来解释这个定义。

```js

function foo() {
	var a = 2;
	function bar() {
		console.log( a ); // 2
	}
	
	bar();
}

foo();

```

这段代码看起来和嵌套作用域中的示例代码很相似。基于词法作用域的查找规则，函数bar()可以访问外部作用域中的变量a（这个例子中的是一个RHS引用查询）。

这是闭包吗？

技术上来讲，也许是。但根据前面的定义，确切的说并不是。我认为最准确地用来解释bar()对a的引用的方法是词法作用域的查找规则，而这些规则只是闭包的一部分。（但却是非常重要的一部分！）

从纯技术的角度说，在上面的代码片段中，函数bar()具有一个涵盖foo()作用域的闭包（事实上，涵盖了它能访问的所有作用域，比如全局作用域。）也可以认为bar()被封闭在foo()的作用域中。为什么呢？原因简单明了，因为bar()嵌套在foo()内部。

但是通过这种方式定义的闭包并不能直接进行观察，也无法明白在这个代码片段中闭包是如何工作的。我们可以很容易地理解此法作用于，而闭包则隐藏在代码之后的神秘阴影里，并不那么容易理解。

下面我们来看一段代码，清晰地展示了闭包：

```js

function foo() {
	var a = 2;
	function bar() {
		console.log( a );
	}
	
	return bar;
};
var baz = foo();
baz(); // a --- 朋友，这就是闭包的效果

```

函数bar()的词法作用域能够访问foo()的内部作用域。然后我们将bar()函数本身当做一个值类型进行传递。这个例子中，我们将bar所引用的函数对象本身当做返回值。

在foo()执行后，其返回值（也就是内部的bar()函数）赋值给变量baz并调用baz()，实际上只是通过不同的标识符引用调用了内部的函数bar()。

bar()显然可以被正常执行。但是这个例子中，它在自己定义的词法作用域意外的地方执行。

在foo()执行后，通常会期待foo()的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再被使用的内存空间。由于看上去foo()内容不会被在使用，所以很自然会考虑对其进行回收。

而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是bar()本身在使用。

拜bar()所声明的位置所赐，它拥有涵盖foo()内部作用域的闭包，是的该作用域能够一直存活，一共bar()在之后任何时间进行引用。

bar()依然持有对该作用域的引用，而这个引用就叫做闭包。

因此，在几微秒之后变量baz被实际调用（调用内部函数bar），不出意料它可以访问定义时的词法作用域，因此它也可以入预期般访问变量a。

这个函数在定义是的词法作用域意外的地方被调用。闭包是的函数可以继续访问定义时的此法作用于。

当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。

```js

function foo() {
	var a = 2;
	function baz() {
		console.log( a ); // 2
	}

	bar( baz );
}

function bar(fn) {
	fn(); // 妈妈快看呀， 这就是闭包！
}

```

把内部函数baz传递给bar，当调用这个内部函数时（现在叫做fn），它涵盖的foo()内部作用域的闭包就可以观察到，因为它能够访问a。

传递函数当然也可以是间接的。

```js

var fn;
function foo() {
	var a = 2;
	function baz() {
		console.log( a );
	}

	fn = baz; // 将baz分配给全局变量
}

function bar() {
	fn(); //妈妈快看呀， 这就是闭包！
}

foo();

bar(); // 2

```

无论通过何种手段将内部函数传递到所在作用域意外，它都会持有对原始定义作用域的引用，无论在何处这个函数都会形成闭包。







